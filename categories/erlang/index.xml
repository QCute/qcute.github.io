<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on 轻作</title><link>https://qcute.github.io/categories/erlang/</link><description>Recent content in erlang on 轻作</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 04 Mar 2020 00:00:00 +0800</lastBuildDate><atom:link href="https://qcute.github.io/categories/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>Erlang ETS内部数据结构</title><link>https://qcute.github.io/posts/erlang/beam-ets/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-ets/</guid><description>1. set/bag/duplicate_bag使用的是哈希表 IS_HASH_TABLE 2. ordered_set使用的是AVL树 IS_TREE_TABLE 为了提升并发写性能, 在OTP22之后引入了CAS(contention adapting search)树 IS_CATREE_TABLE 参考Er</description></item><item><title>Erlang持久对象(Persistent Term)</title><link>https://qcute.github.io/posts/erlang/persistent-term/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/persistent-term/</guid><description>持久对象(Persistent Term)是OTP-21.3之后引入的, 它的get是非复制(Copy)的 persistent_term_get_1 lookup get_bucket 而ETS的get是复制(Copy)的 ets_lookup_2 db_get_hash build_term_list 在游戏服务器里面, 配置表通常会用ETS或者beam</description></item><item><title>Erlang更新Record的优化</title><link>https://qcute.github.io/posts/erlang/beam-set-tuple-element/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-set-tuple-element/</guid><description>Record的更新使用的是erlang:setelement/3, 在更新多个字段的时候很浪费性能以及内存 后来引入了一个破坏性的优化指令: set_tuple_element -record(record, {a, b, c, d, e, f}). update(R) -&amp;gt; R#record{a = 1, b = 2}. {function, update, 1, 8}. {label,7}. {line,[{location,&amp;#34;test.erl&amp;#34;,3}]}. {func_info,{atom,user_default},{atom,update},1}. {label,8}. {test,is_tagged_tuple,{f,9},[{x,0},7,{atom,record}]}. {allocate,0,1}. {move,{x,0},{x,1}}. {move,{integer,2},{x,2}}. {move,{integer,3},{x,0}}. {line,[{location,&amp;#34;test.erl&amp;#34;,4}]}. {call_ext,3,{extfunc,erlang,setelement,3}}. {set_tuple_element,{integer,1},{x,0},1}.</description></item><item><title>Erlang进程表</title><link>https://qcute.github.io/posts/erlang/beam-process-table/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-process-table/</guid><description>以前以为进程表是用B树之类的存储, 后来才发现是用索引表 参考Erlang内部文档 进程和端口表 代码 ErtsPTab 学习了</description></item><item><title>Erlang实现函数内的循环</title><link>https://qcute.github.io/posts/erlang/erlang-loop/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/erlang-loop/</guid><description>erlang语义上绑定的变量是不可变的, 函数内也没有for/while/loop等循环 但是, 函数式语言, 函数是第一等公民, 当然是可以通过命名高阶函数实现循环 -module(test). main(_) -&amp;gt; Sum = fun Loop(10, Sum) -&amp;gt; Sum; Loop(N, Sum) -&amp;gt; Loop(N + 1, Sum + N) end(1, 0), io:format(&amp;#34;loop:</description></item><item><title>Erlang异步的实现</title><link>https://qcute.github.io/posts/erlang/erlang-async/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/erlang-async/</guid><description>对于Bif 使用的是BIF_TRAP宏 #define ERTS_BIF_PREP_TRAP(Export, Proc, Arity) \ do { \ (Proc)-&amp;gt;i = (Export)-&amp;gt;addresses[erts_active_code_ix()]; \ (Proc)-&amp;gt;arity = (Arity); \ (Proc)-&amp;gt;freason = TRAP; \ } while(0); #define BIF_TRAP1(Trap_, p, A0) \ do { \ Eterm* reg = erts_proc_sched_data((p))-&amp;gt;registers-&amp;gt;x_reg_array.d; \ ERTS_BIF_PREP_TRAP((Trap_), (p), 1); \ reg[0] = (A0); \ return THE_NON_VALUE; \ } while(0) 可见, 保存当前PC, 寄存器数和失败原因还有调用参数 beam_hot.</description></item><item><title>编译Erlang虚拟机</title><link>https://qcute.github.io/posts/erlang/compile-otp/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/compile-otp/</guid><description>环境为RHEL/CentOS/RockyLinux 8 1. 安装编译依赖 # 基础curses/ssl dnf install gcc make ncurses-devel openssl-devel -y # 可选hipe依赖 dnf install llvm autoconf m4 -y # 启用epel仓库 dnf install epel-release -y # 可选jdk/odbc/wxWidge</description></item><item><title>使用VSCode调试Erlang虚拟机</title><link>https://qcute.github.io/posts/erlang/debug-otp-with-vscode/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/debug-otp-with-vscode/</guid><description>1. 下载OTP源码 git clone git@github.com:erlang/otp.git &amp;amp;&amp;amp; cd otp 2. 配置 ./configure --enable-kernel-poll --enable-fips --enable-m64-build --with-dynamic-trace=systemtap 3. 以调试模式编译 make -j &amp;#34;$(grep -c &amp;#34;processor&amp;#34; /proc/cpuinfo)&amp;#34; TYPE=debug FLAVOR=smp 4. 安装VSCode插件 安装C/C++插件 安装Makefile插件 安装Remote - SSH插件(远程需要) 5. 在OTP根目录建立</description></item></channel></rss>