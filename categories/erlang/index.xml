<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>erlang on 轻作</title><link>https://qcute.github.io/categories/erlang/</link><description>Recent content in erlang on 轻作</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 04 Mar 2020 00:00:00 +0800</lastBuildDate><atom:link href="https://qcute.github.io/categories/erlang/index.xml" rel="self" type="application/rss+xml"/><item><title>Erlang ETS内部数据结构</title><link>https://qcute.github.io/posts/erlang/beam-ets/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-ets/</guid><description>1. set/bag/duplicate_bag使用的是哈希表 IS_HASH_TABLE 2. ordered_set使用的是AVL树 IS_TREE_TABLE 为了提升并发写性能, 在OTP22之后引入了CAS(contention adapting search)树 IS_CATREE_TABLE 参考Er</description></item><item><title>Erlang持久对象(Persistent Term)</title><link>https://qcute.github.io/posts/erlang/persistent-term/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/persistent-term/</guid><description>持久对象(Persistent Term)是OTP-21.3之后引入的, 它的get是非复制(Copy)的 persistent_term_get_1 lookup get_bucket 而ETS的get是复制(Copy)的 ets_lookup_2 db_get_hash build_term_list 在游戏服务器里面, 配置表通常会用ETS或者beam</description></item><item><title>Erlang更新Record的优化</title><link>https://qcute.github.io/posts/erlang/beam-set-tuple-element/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-set-tuple-element/</guid><description>Record的更新使用的是erlang:setelement/3, 在更新多个字段的时候很浪费性能以及内存 后来引入了一个破坏性的优化指令: set_tuple_element -record(record, {a, b, c, d, e, f}). update(R) -&amp;gt; R#record{a = 1, b = 2}. {function, update, 1, 8}. {label,7}. {line,[{location,&amp;#34;test.erl&amp;#34;,3}]}. {func_info,{atom,user_default},{atom,update},1}. {label,8}. {test,is_tagged_tuple,{f,9},[{x,0},7,{atom,record}]}. {allocate,0,1}. {move,{x,0},{x,1}}. {move,{integer,2},{x,2}}. {move,{integer,3},{x,0}}. {line,[{location,&amp;#34;test.erl&amp;#34;,4}]}. {call_ext,3,{extfunc,erlang,setelement,3}}. {set_tuple_element,{integer,1},{x,0},1}.</description></item><item><title>Erlang函数调用方式性能</title><link>https://qcute.github.io/posts/erlang/apply/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/apply/</guid><description>老生常谈的, 包括Myths, 下面测试下几种调用方式的性能差距。 test_apply() -&amp;gt; L = lists:seq(1, 10000000), LocalTime = os:timestamp(), [jp() || _ &amp;lt;- L], RemoteTime = os:timestamp(), [?MODULE:jp() || _ &amp;lt;- L], ApplyTime = os:timestamp(), [apply(?MODULE, jp, []) || _ &amp;lt;- L], ExecuteTime = os:timestamp(), Module = ?MODULE, Function = jp, [Module:Function() || _ &amp;lt;- L], ApplyFunctionTime = os:timestamp(), [apply(fun ?MODULE:jp/0, []) || _ &amp;lt;- L], ExecuteFunctionTime = os:timestamp(), F = fun ?MODULE:jp/0, [F() || _ &amp;lt;- L], LambdaFunctionTime</description></item><item><title>Erlang进程表</title><link>https://qcute.github.io/posts/erlang/beam-process-table/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/beam-process-table/</guid><description>以前以为进程表是用B树之类的存储, 后来才发现是用索引表 参考Erlang内部文档 进程和端口表 代码 ErtsPTab 学习了</description></item><item><title>Erlang进程字典</title><link>https://qcute.github.io/posts/erlang/process-dict/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/process-dict/</guid><description>进程字典使用的是hash分片方式存放 ProcDict 进程字典的get是非复制(Copy)的 pd_hash_get_with_hval 进程字典的put也是非复制(Copy)的 pd_hash_put 存放单个时使用tuple, 多个(哈希冲突), 使用list, 然后线性查找。</description></item><item><title>Erlang热更新的实现</title><link>https://qcute.github.io/posts/erlang/code/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/code/</guid><description>erts_code_purger.erl 硬清除 erts_code_purger:purge/2 软清除 erts_code_purger:soft_purge/2 code.erl 加载文件(模块) code_server:load_file/3 加载模块 code_server:try_load_module_2/6 两个核心函数 erlang:prepare_loading/2 包装函数 erts_internal_prepare_loading_2 主函数 erts_prepare_loading 读取(解码)字节码 beamfile_read 加载字节码 load_code erlang:finish_loading/1 主函数 finish_loading_1</description></item><item><title>Erlang实现函数内的循环</title><link>https://qcute.github.io/posts/erlang/erlang-loop/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/erlang-loop/</guid><description>erlang语义上绑定的变量是不可变的, 函数内也没有for/while/loop等循环 但是, 函数式语言, 函数是第一等公民, 当然是可以通过命名高阶函数实现循环 -module(test). main(_) -&amp;gt; Sum = fun Loop(10, Sum) -&amp;gt; Sum; Loop(N, Sum) -&amp;gt; Loop(N + 1, Sum + N) end(1, 0), io:format(&amp;#34;loop:</description></item><item><title>Erlang异步的实现</title><link>https://qcute.github.io/posts/erlang/erlang-async/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/erlang-async/</guid><description>对于Bif 使用的是BIF_TRAP宏 #define ERTS_BIF_PREP_TRAP(Export, Proc, Arity) \ do { \ (Proc)-&amp;gt;i = (Export)-&amp;gt;addresses[erts_active_code_ix()]; \ (Proc)-&amp;gt;arity = (Arity); \ (Proc)-&amp;gt;freason = TRAP; \ } while(0); #define BIF_TRAP1(Trap_, p, A0) \ do { \ Eterm* reg = erts_proc_sched_data((p))-&amp;gt;registers-&amp;gt;x_reg_array.d; \ ERTS_BIF_PREP_TRAP((Trap_), (p), 1); \ reg[0] = (A0); \ return THE_NON_VALUE; \ } while(0) 可见, 保存当前PC, 寄存器数和失败原因还有调用参数 beam_hot.</description></item><item><title>Erlang异常性能</title><link>https://qcute.github.io/posts/erlang/exception/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/exception/</guid><description>因为erlang没有提前返回, 所以需要提前返回, 异常是一个不错的想法, 但又怕有性能问题, 下面来测试下。 ts_exception() -&amp;gt; {LoopOnly, _} = timer:tc(?MODULE, loop_only, [1000000, none, undefined, undefined]), {LoopInTryCatchOnly, _} = timer:tc(?MODULE, loop_in_try_catch_only, [1000000, none, undefined]), {LoopInTryCatchStacktraceOnly, _} = timer:tc(?MODULE, loop_in_try_catch_stacktrace_only, [1000000, none, undefined, undefined]), {LoopInCatchOnly, _} = timer:tc(?MODULE, loop_in_catch_only, [1000000, none]), {TryCatchThrow, _} = timer:tc(?MODULE, loop_try_catch, [1000000, throw, undefined]), {TryCatchError, _} = timer:tc(?MODULE, loop_try_catch, [1000000,</description></item><item><title>编译Erlang虚拟机</title><link>https://qcute.github.io/posts/erlang/compile-otp/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/compile-otp/</guid><description>环境为RHEL/CentOS/RockyLinux 8 1. 安装编译依赖 # 基础curses/ssl dnf install gcc make ncurses-devel openssl-devel -y # 可选hipe依赖 dnf install llvm autoconf m4 -y # 启用epel仓库 dnf install epel-release -y # 可选jdk/odbc/wxWidge</description></item><item><title>使用VSCode调试Erlang虚拟机</title><link>https://qcute.github.io/posts/erlang/debug-otp-with-vscode/</link><pubDate>Wed, 04 Mar 2020 00:00:00 +0800</pubDate><guid>https://qcute.github.io/posts/erlang/debug-otp-with-vscode/</guid><description>1. 下载OTP源码 git clone git@github.com:erlang/otp.git &amp;amp;&amp;amp; cd otp 2. 配置 ./configure --enable-kernel-poll --enable-fips --enable-m64-build --with-dynamic-trace=systemtap 3. 以调试模式编译 make -j &amp;#34;$(grep -c &amp;#34;processor&amp;#34; /proc/cpuinfo)&amp;#34; TYPE=debug FLAVOR=smp 4. 安装VSCode插件 安装C/C++插件 安装Makefile插件 安装Remote - SSH插件(远程需要) 5. 在OTP根目录建立</description></item></channel></rss>